<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Emociones (TEA) ‚Äì Teachable Machine</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>
  <style>
    body { font-family: system-ui, Arial; display:flex; flex-direction:column; align-items:center; gap:12px; margin:20px; }
    #webcam-container { border: 2px solid #ddd; border-radius: 12px; padding: 8px; }
    #result { font-size: 3rem; line-height: 1.2; text-align: center; min-height: 3.5rem; }
    #word { font-size: 2rem; margin-top: 6px; text-align:center; }
    #label-container { font-family: monospace; color:#666; }
    button { padding:10px 16px; border-radius:10px; border:1px solid #ccc; cursor:pointer; }
  </style>
</head>
<body>
  <h1>Detector de Emociones</h1>

  <button type="button" onclick="init()">Iniciar c√°mara</button>

  <div id="webcam-container"></div>

  <!-- Salida grande para el aula -->
  <div id="result">üôÇ</div>
  <div id="word"></div>

  <!-- (Opcional) Probabilidades por clase para depurar -->
  <div id="label-container"></div>

  <script>
    // 1) URL de tu modelo (deja la barra final):
    const URL = "https://teachablemachine.withgoogle.com/models/MuwMiHRjm/";

    // 2) Mapea nombre de clase -> emoji y palabra a mostrar
    const EMOJIS = {
      "Alegr√≠a": "üòä",
      "Tristeza": "üò¢",
      "Enojo": "üò°",
      "Miedo": "üò®"
    };

    // 3) (Opcional) Sonidos por emoci√≥n. Coloca los .mp3 junto a este HTML.
    const SOUNDS = {
      "Alegr√≠a": new Audio("alegria.mp3"),
      "Tristeza": new Audio("tristeza.mp3"),
      "Enojo": new Audio("enojo.mp3"),
      "Miedo": new Audio("miedo.mp3")
    };

    // 4) Umbral para ‚Äúacierto‚Äù y antirruido para no disparar sonido todo el tiempo
    const THRESHOLD = 0.85;
    let lastLabel = "";         // √∫ltima emoci√≥n mostrada
    let lastPlayTime = 0;       // √∫ltima vez que son√≥ (ms)
    const COOLDOWN_MS = 1200;   // espera m√≠nima entre sonidos

    let model, webcam, labelContainer, maxPredictions;

    async function init() {
      const modelURL = URL + "model.json";
      const metadataURL = URL + "metadata.json";

      model = await tmImage.load(modelURL, metadataURL);
      maxPredictions = model.getTotalClasses();

      // Webcam
      const flip = true;
      webcam = new tmImage.Webcam(300, 225, flip);
      await webcam.setup();
      await webcam.play();
      window.requestAnimationFrame(loop);

      // Inserta el canvas de la webcam
      document.getElementById("webcam-container").appendChild(webcam.canvas);

      // Contenedor para ver probabilidades (√∫til para ajustar el umbral)
      labelContainer = document.getElementById("label-container");
      labelContainer.innerHTML = "";
      for (let i = 0; i < maxPredictions; i++) {
        const div = document.createElement("div");
        labelContainer.appendChild(div);
      }
    }

    async function loop() {
      webcam.update();
      await predict();
      window.requestAnimationFrame(loop);
    }

    async function predict() {
      const predictions = await model.predict(webcam.canvas);

      // Mostrar probabilidades (depuraci√≥n/seguimiento)
      predictions.forEach((p, i) => {
        labelContainer.childNodes[i].innerHTML = `${p.className}: ${p.probability.toFixed(2)}`;
      });

      // Escoger la clase con mayor probabilidad
      let best = predictions[0];
      for (let i = 1; i < predictions.length; i++) {
        if (predictions[i].probability > best.probability) best = predictions[i];
      }

      // Si supera el umbral, mostramos emoji + palabra y (opcional) reproducimos sonido
      if (best.probability >= THRESHOLD && EMOJIS[best.className]) {
        showResult(best.className);

        // Reproducir sonido solo si cambi√≥ la etiqueta y pas√≥ el cooldown
        const now = Date.now();
        if (best.className !== lastLabel && SOUNDS[best.className] && (now - lastPlayTime > COOLDOWN_MS)) {
          try { SOUNDS[best.className].currentTime = 0; SOUNDS[best.className].play(); } catch(e) {}
          lastPlayTime = now;
        }
        lastLabel = best.className;
      } else {
        // Si no supera el umbral, no cambiamos la pantalla (evita parpadeos)
      }
    }

    function showResult(label) {
      const emoji = EMOJIS[label] || "üôÇ";
      const word = label || "";
      document.getElementById("result").textContent = emoji;
      document.getElementById("word").textContent = word;
    }
  </script>
</body>
</html>
